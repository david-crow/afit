\documentclass[../main.tex]{subfiles}

\begin{document}

Reference \cite{wikipedia:local-search} says the following of local search:

\begin{quote}
    ``In computer science, local search is a heuristic method for solving computationally hard optimization problems. Local search can be used on problems that can be formulated as finding a solution maximizing a criterion among a number of candidate solutions. Local search algorithms move from solution to solution in the space of candidate solutions (the search space) by applying local changes, until a solution deemed optimal is found or a time bound is elapsed.''
\end{quote}

In our third attempt to solve \prob, we employ \ac{lbs}, a local search algorithm much like the previous section's \acl{sbs} \cite{wikipedia:beam-search, Russell2009}. Where \ac{lbs} differs from \ac{sbs}, however, is in the candidate selection method. As a reminder, \ac{sbs} \textit{probabilistically} selects the best $k$ candidates from the \texttt{open} set to evaluate at each time step. \ac{lbs}, on the other hand, \textit{always} selects the best $k$ candidates. The astute reader will recognize that \ac{lbs} is thus likely to get stuck in local optima without often reaching the global optimum. We expect the same, but effective experimentation principles suggest we attempt to solve \probs with more than just two approaches.

As in Sections \ref{sec:deterministic} and \ref{sec:stochastic}, we must employ the \ac{pdad} process to effectively develop an \ac{lbs} algorithm. Like in those sections, we refine the standard search constructs (see Table \ref{tab:search-constructs}) from the algorithm domain (see Section \ref{sec:domain}) to our exact \ac{lbs} implementation.

The \ac{pdad} process's steps 2--6 for the local approach to \probs are discussed in the remainder of this section. Details for these steps can be found in Sections \ref{loc:specification}, \ref{loc:refinement}, \ref{loc:pseudocode}, and \ref{loc:implementation}.

\subsection{Design Specification}\label{loc:specification}

The \ac{pdad} process's step 2 requires that we select an algorithm domain specification strategy. The standard search constructs for our eventual \ac{lbs} implementation are defined as follows:

\begin{itemize}
    \item Set of candidates
    \begin{itemize}
        \item \ac{lbs} stores its set of candidates in an \texttt{open} list
        \item To reduce the search space, we also store \textit{visited} candidates in a \texttt{closed} list
    \end{itemize}
    
    \item Next-state generator
    \begin{itemize}
        \item Given an empty world of size $d\times d$, we create $P(4d-4,n)$ initial next-states, one for each starting configuration of $n$ \acp{uav}
        \item For a given world, the set of next-states includes all copies of the world with one additional movement of one \ac{uav}
        \begin{itemize}
            \item \textit{Constraint}: the \ac{uav}'s path length $p$ must be less than $b$
            \item \textit{Constraint}: the \ac{uav} cannot move to a non-edge square if $p=b-1$
        \end{itemize}
    
    \end{itemize}
    
    \item Feasibility
    \begin{itemize}
        \item For a given state $S$, determine whether, for every \ac{uav} $u\in S$, $u$ is on an edge square and either \textit{a)} remaining\_battery($u$) $=0$ or \textit{b)} every square $s\in S$ is covered
        \item Determine whether $S$ meets constraints defined in the problem domain
    \end{itemize}

    \item Selection
    \begin{itemize}
        \item \ac{lbs} always selects the $k$ candidates with the lowest $h(S)$ values, where $S$ is the state, and $h(S)$ is the estimate of the remaining cost to the goal
        \item Delete those candidates for which $\exists u\in$ \acp{uav} such that remaining\_battery($u$) $=0$ and $u$ is not on an edge square
        \item Additionally, delete all but the best $k$ candidates
        \begin{itemize}
            \item To ensure our \ac{lbs} \probs\ implementation is computationally-tractable, let $k=5$ \cite{wikipedia:computational_complexity_theory}
        \end{itemize} 
    \end{itemize}

    \pagebreak

    \item Solution
    \begin{itemize}
        \item If \textit{feasibility} constraints are met and $V_S$ is minimized, return $S$
    \end{itemize}

    \item Objective
    \begin{itemize}
        \item Minimize $f(S)$ using \textit{heuristics} (defined in Section \ref{loc:refinement}) while meeting the \textit{feasibility} constraints
    \end{itemize}
\end{itemize}

\subsection{Design Refinement}\label{loc:refinement}

The third and fourth steps in the \acl{pdad} process require that one evolves a general solution design specification and instantiates the problem design. We now discuss the abstract data types and structures required in our \ac{lbs} implementation. We also refine the standard search elements first defined in the previous section.

We know that step 6 of the \ac{pdad} is functional Python code, so we must specify the \ac{lbs} data structures used to solve \probs before actually programming. We stated earlier that \ac{lbs} requires \texttt{open} and \texttt{closed} sets, so we believe that Python-style lists will prove effective for this research. 

As in Sections \ref{det:refinement} and \ref{sto:refinement}, we now refine the high-level standard search constructs into a more practical form. In doing so, we can more easily map our problem and algorithm domains onto a functioning software implementation.

\begin{itemize}
    \item Set of candidates
    \begin{itemize}
        \item open $=\emptyset$
        \item closed $=\emptyset$
    \end{itemize}
    
    \item Next-state generator
    \begin{itemize}
        \item If $S=\emptyset$, $\forall c\in$ start\_configurations, $S=S\cup \{c\}$
        \item Otherwise, $\forall u\in$ \acp{uav} and $\forall a\in$ adjacent\_squares$_u$, $S=S\cup \{u\cup \{u_a\}\}$
        \begin{itemize}
            \item \textit{Constraint}: $|u|\leq b$
            \item \textit{Constraint}: If $p=b-1$, let adjacent\_squares$_u=$ adjacent\_edge\_squares$_u$
        \end{itemize}
    \end{itemize}
    
    \item Feasibility
    \begin{itemize}
        \item Feasible if, $\forall u\in$ \acp{uav}, edge(location($u$)) $=1$ and one of the following holds:
        \begin{itemize} 
            \item remaining\_battery($u$) $=0$
            \item $\forall s\in S$, covered($s$) $=1$
        \end{itemize}

        \item Additionally, each of these problem domain constraints must hold:
        \begin{itemize}
            \item $|P|=n$; every \ac{uav} must have a path (even if the path is empty)
            \item $\forall p\in P, |p|\leq b$; no \ac{uav} can fly more than $b$ unit squares
            \item $\forall p\in P, \ edge(first(p)) = 1, \ edge(last(p)) = 1$; every \ac{uav} must start and end on an edge square
            \item $\forall Q, \ Q\neq P \Rightarrow V_Q<V_P$; the value of the path set $P$ must be maximal
        \end{itemize}
    \end{itemize}

    \item Selection
    \begin{itemize}
        \item At each time $t$, select up to $k=5$ $\argmax_S h(S)$
        \item Delete $S$ if $\exists u\in$ \acp{uav} s.t. remaining\_battery($u$) $=0$ and edge(location($u$)) $\neq 1$
    \end{itemize}

    \pagebreak
    
    \item Solution
    \begin{itemize}
        \item Return \[
            \begin{cases}
                S & \text{if feasibility(}S\text{)}=1 \text{ and }V_s\text{ is maximized} \\
                \emptyset & \text{otherwise} \\
            \end{cases}
        \]
    \end{itemize}

    \item Objective
    \begin{itemize}
        \item Maximize $f(S)$ using \textit{heuristics} while meeting the \textit{feasibility} constraints
        \item As defined in the problem domain, $f(S)=v$, the overall state value, which concerns the following: 
        \begin{itemize}
            \item Maximized $\sum_{i=1}^{n}{squares\_covered_i}$
            \item Minimized $\sum_{i=1}^{n}{risk_i}$
        \end{itemize}
    \end{itemize}

    \item Heuristics
    \begin{itemize}
        \item For a given state $S$, $h(S)$ concerns the following:
        \begin{itemize}
            \item $total\_ratio=squares\_covered\div d^2$
            \item $edge\_ratio=edges\_covered\div (4d-4)$
            \item $same\_repeats$, number of times a \ac{uav} visits a square it has already visited
            \item $other\_repeats$, number of times a \ac{uav} visits a square another \ac{uav} has already visited
            \item $risk=total\_risk\div path\_length$
        \end{itemize}
    \end{itemize}
\end{itemize}

\subsection{Pseudocode}\label{loc:pseudocode}

We must develop effective pseudocode in step 5 of the \ac{pdad} process. The \ac{lbs} implementation used in this research is extremely similar to the \ac{sbs} implementation detailed in Section \ref{sec:stochastic}. For this reason, the Python implementation consists of just one class, and this class contains the A$^*$, \ac{sbs}, and \ac{lbs} implementations. The pseudocode given here contains only the essential \ac{lbs} functionality -- the various library imports, print statements, and single-value computations are not essential to the reader's understanding of \ac{lbs}'s functionality. Further details of these functions are given in Appendix \ref{app:code}. 

We know that \acl{lbs} requires a \texttt{frontier} set and an \texttt{explored} set; we believe that Python lists will suffice for these sets. Each \texttt{world} instance (that is, the \ac{2d} $d\times d$ grid that contains the \probs sensors and the \ac{uav} paths) is contained within a \ac{2d} Python list; the path sets are also stored as \ac{2d} lists. All other data structures are one of the primitive Python types: \texttt{string}, \texttt{integer}, \texttt{float}, or \texttt{boolean} \cite{python:primitives}.

Pseudocode for the local approach is shown in Algorithm \ref{fig:loc-pseudocode}. The reader can see that the standard search elements are embedded as comments.

\begin{algorithm}
\caption{A Local Approach for \prob}
\label{fig:loc-pseudocode}
    \begin{algorithmic}[1]
        \REQUIRE $w$, an empty $d\times d$ grid
        \REQUIRE $p$, a set of $n$ empty paths
        \ENSURE $p'$, a set of $n$ paths
        \ENSURE $v$, the value of $p'$ in $w$

        \STATE \textcolor{red}{// set of candidates}
        \STATE frontier $=\emptyset$
        \STATE explored $=\emptyset$

        \FOR{each starting configuration $s$ of $n$ \acp{uav} in $w$}
            \STATE new\_world $=w$
            \STATE new\_paths $=p$

            \FOR{all $u\in$ \acp{uav}}
                \STATE new\_world[location($u$)] $=1$
                \STATE new\_paths $=$ new\_paths$_u$ $\cup$ \{location($u$)\}
            \ENDFOR

            \STATE $v=$ value(new\_world, new\_paths)
            \STATE frontier $=$ frontier $\cup$ \{$v$, new\_world, new\_paths\}
        \ENDFOR

        \WHILE{$|$frontier$|\neq 0$}
            \STATE \textcolor{red}{// selection}
            \STATE $v,w,p=$ frontier.pop\_front()
            \STATE explored $=$ frontier $\cup\ \{w\}$

            \STATE \textcolor{red}{// objective}
            \IF{$\forall u\in$ \acp{uav}, edge(location($u$)) $=1$ \AND every square is covered or every \ac{uav}'s battery is depleted}
                \STATE \textcolor{red}{// solution}
                \RETURN $(w,p)$
            \ENDIF

            \STATE \textcolor{red}{// feasibility}
            \FOR{all $u\in$ \acp{uav}}
                \IF{$u$'s battery has $1$ unit remaining}
                    \STATE neighbors $=$ adjacent\_edges($u$)
                \ELSE
                    \STATE neighbors $=$ adjacent($u$)
                \ENDIF

                \FOR{all $q\in$ neighbors}
                    \STATE $w'=w$
                    \STATE $p'=p$
                    \STATE $w'$[location($q$)] $=1$
                    \STATE $p'_u=p'_u\ \cup$ location($q$)
                    \STATE state $=$ \{value($w',p'$), $w'$, $p'$\}
                    \IF{state $\notin$ frontier \AND state $\notin$ explored}
                        \STATE \textcolor{red}{// next-state generator}
                        \STATE frontier $=$ frontier $\cup$ \{state\}
                    \ENDIF
                \ENDFOR
            \ENDFOR

            \STATE \textcolor{red}{// heuristics}
            \STATE frontier $=$ frontier.select\_best($5$)
        \ENDWHILE
        \RETURN ``No solution found!"
    \end{algorithmic}
\end{algorithm}

\subsection{Implementation}\label{loc:implementation}

Step 6 of the \ac{pdad} process, which requires a one-to-one mapping from Section \ref{loc:pseudocode} pseudocode to an actual, executable implementation, is described in this section. Like we did with the other search techniques, we decided to implement the \ac{lbs} function in Python because it an easy-to-write language, it's moderately-fast, and it has a large, well-documented set of tools. For the third time, we used PyCharm Professional 2019.1 on a 2017 MacBook Pro to develop the search algorithm's implementation.

As before, this code was written using good software development principles. Our undergraduate- and graduate-level computer science courses in software engineering -- and the previously-cited references \cite{Sommerville2010, Gamma1994, Gomaa2011} -- serve as useful softare engineering resources when we have questions about effective good enginerring principles.

The \ac{lbs} implementation is extremely similar to the \ac{sbs} implementation, so the algorithm's complexity is exactly the same as described in Section \ref{sto:implementation}. For clarity, we restate that complexity here: $O(n\times P(4d-4,n)+8n^2\times P(d^2,b)\div 5)=O(n^2\times P(d^2,b))$.

The reader can view the full Python \probs implementation -- including \acl{lbs} -- in Appendix \ref{app:code}.

\end{document}